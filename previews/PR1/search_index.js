var documenterSearchIndex = {"docs":
[{"location":"cli/#CLI-Reference","page":"CLI Reference","title":"CLI Reference","text":"TTCalX is invoked via the ttcal_gpu.jl script (or the ttcalx shell alias on calim servers).","category":"section"},{"location":"cli/#Usage","page":"CLI Reference","title":"Usage","text":"julia bin/ttcal_gpu.jl <command> [options] <sources.json> <ms1> [ms2] ...\n\nOr with the alias:\n\nttcalx <command> [options] <sources.json> <ms1> [ms2] ...","category":"section"},{"location":"cli/#Commands","page":"CLI Reference","title":"Commands","text":"Command Description\npeel Diagonal Jones matrices, per frequency channel\nzest Full Jones matrices, per frequency channel\nshave Diagonal Jones matrices, wideband (one per subband)\nprune Full Jones matrices, wideband (one per subband)","category":"section"},{"location":"cli/#Options","page":"CLI Reference","title":"Options","text":"Option Default Description\n--maxiter=N 30 Maximum StEFCal iterations per source per peel iteration\n--tolerance=T 1e-4 Relative convergence tolerance\n--minuvw=M 10.0 Minimum baseline length in wavelengths\n--peeliter=P 3 Number of peeling iterations over all sources\n--column=COL CORRECTED_DATA MS data column to read and write\n--verbose  Show detailed diagnostic output (source-by-source progress)\n--quiet  Suppress all output except errors\n--help  Show help message and exit","category":"section"},{"location":"cli/#Examples","page":"CLI Reference","title":"Examples","text":"","category":"section"},{"location":"cli/#Basic-peeling","page":"CLI Reference","title":"Basic peeling","text":"julia bin/ttcal_gpu.jl peel sources.json data.ms","category":"section"},{"location":"cli/#Zest-with-custom-parameters","page":"CLI Reference","title":"Zest with custom parameters","text":"julia bin/ttcal_gpu.jl zest --maxiter=50 --tolerance=1e-5 sources.json data.ms","category":"section"},{"location":"cli/#Batch-processing-(recommended)","page":"CLI Reference","title":"Batch processing (recommended)","text":"julia bin/ttcal_gpu.jl zest sources.json *.ms --minuvw=15","category":"section"},{"location":"cli/#Using-DATA-column-(for-split/calibrated-data)","page":"CLI Reference","title":"Using DATA column (for split/calibrated data)","text":"julia bin/ttcal_gpu.jl zest --column=DATA sources.json test.ms","category":"section"},{"location":"cli/#Exit-Codes","page":"CLI Reference","title":"Exit Codes","text":"Code Meaning\n0 Success\n1 Error (invalid arguments, missing files, missing python-casacore)","category":"section"},{"location":"cli/#Environment-Setup","page":"CLI Reference","title":"Environment Setup","text":"On calim servers, use the convenience alias:\n\n# Add to ~/.bashrc\nalias ttcalx_env='conda activate /opt/devel/pipeline/envs/py38_orca_nkosogor && export PATH=\"/opt/devel/nkosogor/nkosogor/julia-1.10.4/bin:$PATH\" && export JULIA_DEPOT_PATH=\"/tmp/julia_${USER}:/home/pipeline/.julia\"'\nalias ttcalx='julia --project=/opt/devel/nkosogor/nkosogor/TTCalX /opt/devel/nkosogor/nkosogor/TTCalX/bin/ttcal_gpu.jl'\n\nThen:\n\nttcalx_env\nttcalx zest /home/pipeline/sources.json data.ms --verbose","category":"section"},{"location":"kernels/#GPU-Kernels","page":"GPU Kernels","title":"GPU Kernels","text":"TTCalX uses CUDA.jl kernels for all performance-critical operations. Each kernel has a matching CPU fallback that produces identical results.","category":"section"},{"location":"kernels/#Architecture","page":"GPU Kernels","title":"Architecture","text":"The GPU code is organized in src/gpu/kernels/:\n\nFile Purpose\nutils.jl Jones matrix algebra, thread indexing helpers\ngenvis.jl Model visibility generation (point, Gaussian, disk sources)\ncorrupt.jl Corrupt/apply calibration to visibilities\nstefcal.jl StEFCal gain solver iterations","category":"section"},{"location":"kernels/#Jones-Matrix-Operations-(utils.jl)","page":"GPU Kernels","title":"Jones Matrix Operations (utils.jl)","text":"All Jones operations are @inline device-side functions:\n\nFunction Operation\njones_multiply(A, B) C = A cdot B\njones_multiply_conjtrans(A, B) C = A cdot B^dagger\njones_conjtrans(A) A^dagger\njones_det(A) det(A)\njones_inv(A) A^-1\njones_add(A, B) A + B\njones_norm(A) A_F (Frobenius norm)\ndiag_jones_multiply(d, A) Diagonal × Full multiplication\njones_multiply_diag_conjtrans(A, d) Full × Diagonal† multiplication\ndiag_jones_inv(d) Inverse of diagonal Jones","category":"section"},{"location":"kernels/#Model-Visibility-Generation-(genvis.jl)","page":"GPU Kernels","title":"Model Visibility Generation (genvis.jl)","text":"Generates model visibilities for a source at all baselines and frequencies.","category":"section"},{"location":"kernels/#Point-Sources","page":"GPU Kernels","title":"Point Sources","text":"Computes geometric delay fringes using UVW coordinates:\n\nphi = 2pi(u cdot l + v cdot m + w cdot (n - 1))  lambda","category":"section"},{"location":"kernels/#Gaussian-Sources","page":"GPU Kernels","title":"Gaussian Sources","text":"Same as point sources but with baseline coherency attenuation from the Gaussian envelope (Fourier transform of the sky brightness).","category":"section"},{"location":"kernels/#Disk-Sources","page":"GPU Kernels","title":"Disk Sources","text":"Uses Bessel function J_1 for the coherency of a uniform disk model.","category":"section"},{"location":"kernels/#Corrupt-and-Applycal-(corrupt.jl)","page":"GPU Kernels","title":"Corrupt & Applycal (corrupt.jl)","text":"","category":"section"},{"location":"kernels/#Corrupt","page":"GPU Kernels","title":"Corrupt","text":"Apply Jones gains to model visibilities:\n\nV_ij^textcorrupted = J_i  V_ij  J_j^dagger","category":"section"},{"location":"kernels/#Applycal","page":"GPU Kernels","title":"Applycal","text":"Apply inverse calibration:\n\nV_ij^textcorrected = J_i^-1  V_ij  (J_j^-1)^dagger\n\nBoth handle diagonal and full Jones matrices with separate kernel paths.","category":"section"},{"location":"kernels/#StEFCal-Solver-(stefcal.jl)","page":"GPU Kernels","title":"StEFCal Solver (stefcal.jl)","text":"","category":"section"},{"location":"kernels/#Makesquare","page":"GPU Kernels","title":"Makesquare","text":"Reorganizes baseline-indexed visibilities into antenna×antenna matrices for the StEFCal update. Uses split real/imaginary atomic additions on GPU (CUDA does not support atomic ComplexF64).","category":"section"},{"location":"kernels/#StEFCal-Step","page":"GPU Kernels","title":"StEFCal Step","text":"One iteration of the gain update. Each CUDA thread handles one (antenna, frequency) pair.\n\nDiagonal:\n\ng_j^textnew = fracsum_i (G_i M_ij)^dagger V_ijsum_i (G_i M_ij)^dagger (G_i M_ij)\n\nFull 2×2: Explicit matrix inversion at each antenna.","category":"section"},{"location":"kernels/#CPU-Fallback","page":"GPU Kernels","title":"CPU Fallback","text":"When CUDA.functional() returns false, all operations automatically use CPU implementations defined in peel_gpu.jl. The CPU paths are maintained as exact mirrors of the GPU kernels to ensure numerical equivalence.","category":"section"},{"location":"kernels/#Detection-Pattern","page":"GPU Kernels","title":"Detection Pattern","text":"use_gpu = _is_gpu(vis)  # checks if arrays are CuArrays\nif use_gpu\n    # Launch CUDA kernel\nelse\n    # Run CPU loop\nend","category":"section"},{"location":"api/#API-Reference","page":"API Reference","title":"API Reference","text":"note: Note\nFull auto-generated API docs (from docstrings) require loading the TTCalX module, which depends on CUDA and PyCall. The reference below is maintained manually from the source code docstrings.","category":"section"},{"location":"api/#Main-Module-(TTCalX)","page":"API Reference","title":"Main Module (TTCalX)","text":"","category":"section"},{"location":"api/#GPU-Availability","page":"API Reference","title":"GPU Availability","text":"is_gpu_available() → Bool\n\nCheck if a CUDA GPU is available and functional.\n\nget_gpu_backend() → Symbol\n\nReturns :cuda if CUDA is functional, :cpu otherwise.\n\n","category":"section"},{"location":"api/#Data-Types","page":"API Reference","title":"Data Types","text":"","category":"section"},{"location":"api/#Visibilities","page":"API Reference","title":"Visibilities","text":"GPUVisibilities{T,F}\n\nGPU-friendly visibility storage using Struct-of-Arrays layout. Fields: xx, xy, yx, yy (complex arrays), flags (boolean array). Shape: (Nbase, Nfreq).","category":"section"},{"location":"api/#Calibration-Gains","page":"API Reference","title":"Calibration Gains","text":"GPUCalibration{T,F}\n\nGPU-friendly calibration gain storage. Fields: xx, xy, yx, yy, flags, is_diagonal. Shape: (Nant, Nfreq).","category":"section"},{"location":"api/#Metadata","page":"API Reference","title":"Metadata","text":"GPUMetadata{T,V,I}\n\nMetadata container: antenna positions, baseline mapping, channel frequencies, UVW coordinates, phase center.\n\ncreate_gpu_metadata(antenna_positions, baselines, channels, phase_center_ra, phase_center_dec, uvw; gpu=true)\n\nConvenience constructor that transfers to GPU when available.","category":"section"},{"location":"api/#Jones-Matrices","page":"API Reference","title":"Jones Matrices","text":"GPUJonesMatrixArray{T}          # Full 2×2 Jones: xx, xy, yx, yy\nGPUDiagonalJonesMatrixArray{T}  # Diagonal Jones: xx, yy only\nGPUHermitianJonesMatrixArray{T} # Hermitian Jones\n\n","category":"section"},{"location":"api/#Source-Models","page":"API Reference","title":"Source Models","text":"read_gpu_sources(filename::String) → Vector{AbstractGPUPeelingSource}\n\nRead sources from a JSON file in TTCal format.","category":"section"},{"location":"api/#Source-Types","page":"API Reference","title":"Source Types","text":"GPUPointSource     # Unresolved point source\nGPUGaussianSource  # Elliptical Gaussian\nGPUMultiSource     # Multi-component source","category":"section"},{"location":"api/#Peeling-Wrappers","page":"API Reference","title":"Peeling Wrappers","text":"GPUPeelingSource   # Diagonal Jones, per-channel\nGPUShavingSource   # Diagonal Jones, wideband\nGPUZestingSource   # Full Jones, per-channel\nGPUPruningSource   # Full Jones, wideband","category":"section"},{"location":"api/#Source-Utilities","page":"API Reference","title":"Source Utilities","text":"get_name(source) → String\nunwrap(source) → GPUSource\nis_diagonal(source) → Bool\nis_wideband(source) → Bool\nsource_direction_lmn(source, phase_center_ra, phase_center_dec, lst) → (l, m, n)\n\n","category":"section"},{"location":"api/#Peeling-Functions","page":"API Reference","title":"Peeling Functions","text":"peel_gpu!(vis, meta, sources; maxiter=30, tolerance=1e-4, minuvw=10.0, peeliter=3, ...)\nzest_gpu!(vis, meta, sources; maxiter=30, tolerance=1e-4, minuvw=10.0, peeliter=3, ...)\nshave_gpu!(vis, meta, sources; maxiter=30, tolerance=1e-4, minuvw=10.0, peeliter=3, ...)\nprune_gpu!(vis, meta, sources; maxiter=30, tolerance=1e-4, minuvw=10.0, peeliter=3, ...)\n\nMain calibration entry points. Each wraps sources in the appropriate peeling type and runs the iterative peel loop.\n\n","category":"section"},{"location":"api/#Model-Visibilities","page":"API Reference","title":"Model Visibilities","text":"gpu_genvis(meta, source; ...) → GPUVisibilities\n\nGenerate model visibilities for a source (allocates output).\n\ngpu_genvis!(vis, meta, source, ...) \n\nGenerate model visibilities and add to existing data (in-place).\n\n","category":"section"},{"location":"api/#Corrupt-/-Apply-Calibration","page":"API Reference","title":"Corrupt / Apply Calibration","text":"gpu_corrupt!(vis, cal, meta)\n\nApply Jones gains: V_ij leftarrow J_i  V_ij  J_j^dagger\n\ngpu_applycal!(vis, cal, meta)\n\nApply inverse calibration: V_ij leftarrow J_i^-1  V_ij  (J_j^-1)^dagger\n\n","category":"section"},{"location":"api/#StEFCal-Solver","page":"API Reference","title":"StEFCal Solver","text":"gpu_stefcal!(calibration, measured, model, meta; maxiter=30, tolerance=1e-4, ...)\n\nRun the StEFCal solver to find antenna-based Jones gains.\n\n","category":"section"},{"location":"api/#MS-I/O","page":"API Reference","title":"MS I/O","text":"init_pycasacore() → Bool\n\nInitialize python-casacore via PyCall. Must be called before any MS operations.\n\nread_ms_to_gpu(ms_path; gpu=true, column=\"CORRECTED_DATA\")\n    → (vis, cal, meta, baseline_dict, Nrows)\n\nRead a Measurement Set into GPU-friendly data structures.\n\nwrite_gpu_to_ms!(ms_path, vis, baseline_dict, Nrows; column=\"CORRECTED_DATA\")\n\nWrite GPU visibilities back to a Measurement Set.\n\n","category":"section"},{"location":"api/#Memory-Utilities","page":"API Reference","title":"Memory Utilities","text":"to_gpu(x)   # Transfer to GPU (no-op if CUDA unavailable)\nto_cpu(x)   # Transfer to CPU\n\n","category":"section"},{"location":"api/#Logging","page":"API Reference","title":"Logging","text":"set_verbosity(level::Symbol)  # :quiet, :normal, or :verbose\nlog_header(title)\nlog_section(title)\nlog_step(msg)\nlog_substep(msg)\nlog_detail(msg)              # verbose only\nlog_success(msg)\nlog_warning(msg)\nlog_error(msg)","category":"section"},{"location":"msio/#Measurement-Set-I/O","page":"MS I/O","title":"Measurement Set I/O","text":"TTCalX reads and writes CASA Measurement Sets using python-casacore via Julia's PyCall.jl.","category":"section"},{"location":"msio/#Overview","page":"MS I/O","title":"Overview","text":"The MS bridge (src/gpu/pycall_ms_bridge.jl) provides two main functions:\n\nread_ms_to_gpu — Read an MS into GPU-friendly data structures\nwrite_gpu_to_ms! — Write calibrated visibilities back to the MS","category":"section"},{"location":"msio/#Reading-Data","page":"MS I/O","title":"Reading Data","text":"read_ms_to_gpu(ms_path; gpu=true, column=\"CORRECTED_DATA\")\n    → (vis, cal, meta, baseline_dict, Nrows)","category":"section"},{"location":"msio/#What-it-reads","page":"MS I/O","title":"What it reads","text":"MS Column Julia Field Description\nDATA or CORRECTED_DATA vis Complex visibility data\nFLAG vis.flags Boolean flag array\nANTENNA1, ANTENNA2 meta.baselines Baseline → antenna mapping\nUVW meta.uvw Baseline UVW coordinates\nCHAN_FREQ (spectral window) meta.channels Channel frequencies in Hz\nAntenna positions meta.antenna_positions ITRF XYZ positions\nPhase center meta.phase_center_ra/dec Field pointing direction","category":"section"},{"location":"msio/#Data-Layout","page":"MS I/O","title":"Data Layout","text":"Visibilities are stored as Struct-of-Arrays (SoA): separate xx, xy, yx, yy arrays of shape (Nbase, Nfreq)\nAuto-correlations are excluded\nBaselines are indexed via baseline_dict::Dict{Tuple{Int,Int}, Int}","category":"section"},{"location":"msio/#GPU-Transfer","page":"MS I/O","title":"GPU Transfer","text":"When gpu=true and CUDA is functional, all arrays are transferred to GPU memory as CuArray. Otherwise, standard CPU Array is used — the rest of the pipeline works identically.","category":"section"},{"location":"msio/#Writing-Data","page":"MS I/O","title":"Writing Data","text":"write_gpu_to_ms!(ms_path, vis, baseline_dict, Nrows; column=\"CORRECTED_DATA\")\n\nTransfers data from GPU to CPU (if needed), reconstructs the (Nrows, Nfreq, 4) layout expected by casacore, and writes back to the specified column using python-casacore.","category":"section"},{"location":"msio/#Python-Initialization","page":"MS I/O","title":"Python Initialization","text":"The init_pycasacore() function lazily imports casacore.tables and numpy via PyCall. This must be called before any MS operations:\n\nif !init_pycasacore()\n    error(\"python-casacore not available. Install with: pip install python-casacore\")\nend","category":"section"},{"location":"msio/#Dependencies","page":"MS I/O","title":"Dependencies","text":"PyCall.jl — Julia ↔ Python interop\npython-casacore — Python bindings for casacore (MS access)\nnumpy — Array conversion between Python and Julia","category":"section"},{"location":"calibration/#Calibration","page":"Calibration","title":"Calibration","text":"TTCalX implements the StEFCal (Statistically Efficient and Fast Calibration) algorithm on GPU for direction-dependent calibration of radio interferometric data.","category":"section"},{"location":"calibration/#Algorithm-Overview","page":"Calibration","title":"Algorithm Overview","text":"For each bright source, TTCalX solves for antenna-based Jones gains J_i that minimize:\n\nsum_i neq j left V_ij - J_i  M_ij  J_j^dagger right^2\n\nwhere V_ij are the measured visibilities and M_ij are the model visibilities for that source.","category":"section"},{"location":"calibration/#Peeling-Loop","page":"Calibration","title":"Peeling Loop","text":"The peeling procedure iterates over sources multiple times (--peeliter):\n\nPut-back: Add the current best model (corrupted by the last gains) back into the residual visibilities.\nSolve: Run StEFCal to find the best-fit Jones gains for this source.\nSubtract: Remove the source model (corrupted by the new gains) from the data.\n\nAfter all peeling iterations, the residual visibilities contain only the sky signal minus the bright sources.","category":"section"},{"location":"calibration/#StEFCal-Solver","page":"Calibration","title":"StEFCal Solver","text":"The StEFCal update equation for diagonal Jones gains is:\n\ng_j^textnew = fracsum_i (G_i M_ij)^dagger V_ijsum_i (G_i M_ij)^dagger (G_i M_ij)\n\nFor full 2×2 Jones matrices, the update involves a matrix solve per antenna per frequency channel.","category":"section"},{"location":"calibration/#Convergence","page":"Calibration","title":"Convergence","text":"The solver iterates until either:\n\nThe relative change falls below --tolerance: delta g  texttol times g\nThe maximum number of iterations --maxiter is reached\n\nHalf-step damping is applied to improve stability: g leftarrow frac12(g_textold + g_textnew)","category":"section"},{"location":"calibration/#Calibration-Modes","page":"Calibration","title":"Calibration Modes","text":"","category":"section"},{"location":"calibration/#Peel-(diagonal,-per-channel)","page":"Calibration","title":"Peel (diagonal, per-channel)","text":"2 complex parameters per antenna per frequency channel\nBest for amplitude + phase calibration\nFastest mode","category":"section"},{"location":"calibration/#Zest-(full-Jones,-per-channel)","page":"Calibration","title":"Zest (full Jones, per-channel)","text":"4 complex parameters per antenna per frequency channel\nHandles polarization leakage and Faraday rotation\nRecommended for OVRO-LWA data at low frequencies","category":"section"},{"location":"calibration/#Shave-(diagonal,-wideband)","page":"Calibration","title":"Shave (diagonal, wideband)","text":"2 complex parameters per antenna per subband\nFewer degrees of freedom than peel\n⚠️ Currently untested","category":"section"},{"location":"calibration/#Prune-(full-Jones,-wideband)","page":"Calibration","title":"Prune (full Jones, wideband)","text":"4 complex parameters per antenna per subband\nFewer degrees of freedom than zest\n⚠️ Currently untested","category":"section"},{"location":"calibration/#GPU-vs-CPU","page":"Calibration","title":"GPU vs CPU","text":"TTCalX uses CUDA for all heavy computation:\n\nModel visibility generation (genvis): per-baseline fringe computation\nCorrupt / applycal: Jones matrix multiplication per baseline\nStEFCal iterations: gain updates per antenna per frequency\nMakesquare: baseline→antenna-antenna matrix reorganization\n\nWhen CUDA is unavailable, all operations fall back to equivalent CPU implementations automatically. The CPU path produces identical results but is significantly slower.","category":"section"},{"location":"calibration/#Key-Parameters","page":"Calibration","title":"Key Parameters","text":"Parameter Flag Default Description\nMax iterations --maxiter 30 Maximum StEFCal iterations per source per peel iteration\nTolerance --tolerance 1e-4 Relative convergence threshold\nMin UVW --minuvw 10.0 Minimum baseline length in wavelengths (flags shorter baselines)\nPeel iterations --peeliter 3 Number of peeling passes over all sources","category":"section"},{"location":"#TTCalX","page":"Home","title":"TTCalX","text":"GPU-accelerated direction-dependent calibration for the OVRO-LWA.\n\n(Image: License: MIT)","category":"section"},{"location":"#Overview","page":"Home","title":"Overview","text":"TTCalX performs direction-dependent calibration to remove bright radio sources from interferometric data. All heavy computation runs on CUDA GPUs with automatic CPU fallback.\n\nIt is an extended, GPU-accelerated version of the original TTCal by Michael Eastwood.","category":"section"},{"location":"#Calibration-Modes","page":"Home","title":"Calibration Modes","text":"Mode Jones Matrix Frequency Use Case\npeel Diagonal (2 params) Per-channel Phase/amplitude calibration\nzest Full (4 params) Per-channel + Polarization leakage\nshave Diagonal Wideband Fast diagonal calibration\nprune Full Wideband Fast full Jones calibration","category":"section"},{"location":"#Quick-Start","page":"Home","title":"Quick Start","text":"# Activate environment (on calim servers)\nttcalx_env\n\n# Run zest on a measurement set\nttcalx zest /home/pipeline/sources.json data.ms --verbose\n\nFor a full walkthrough, see the Tutorial.","category":"section"},{"location":"#Contents","page":"Home","title":"Contents","text":"Pages = [\n    \"tutorial.md\",\n    \"calibration.md\",\n    \"sources.md\",\n    \"kernels.md\",\n    \"msio.md\",\n    \"cli.md\",\n    \"api.md\",\n]\nDepth = 2","category":"section"},{"location":"#Requirements","page":"Home","title":"Requirements","text":"Julia 1.10+\nNVIDIA GPU with CUDA 11+ (falls back to CPU if unavailable)\nPython 3 with python-casacore (for Measurement Set I/O via PyCall)","category":"section"},{"location":"#Installation","page":"Home","title":"Installation","text":"git clone https://github.com/nkosogor/TTCalX.git\ncd TTCalX\n\njulia -e '\nusing Pkg\nPkg.activate(\".\")\nPkg.instantiate()\nENV[\"PYTHON\"] = Sys.which(\"python\")\nPkg.build(\"PyCall\")\n'","category":"section"},{"location":"sources/#Source-Models","page":"Source Models","title":"Source Models","text":"TTCalX reads source models from a JSON file and converts them to GPU-friendly data structures.","category":"section"},{"location":"sources/#Source-File-Format","page":"Source Models","title":"Source File Format","text":"The source file is a JSON array of source objects. Each source has:\n\nField Required Description\nname ✓ Source name (e.g., \"Cyg A\")\nra ✓ Right ascension — degrees or \"HHhMMmSS.SSs\"\ndec ✓ Declination — degrees or \"+DDdMMmSS.SSs\"\nI ✓ Stokes I flux density (Jy) at reference frequency\nfreq  Reference frequency (Hz) for the spectral model\nindex  Spectral index coefficients [α₁, α₂, ...]\nQ, U, V  Stokes parameters (default: 0)\nmajor-fwhm  Major axis FWHM in arcseconds (Gaussian sources)\nminor-fwhm  Minor axis FWHM in arcseconds (Gaussian sources)\nposition-angle  Position angle in degrees (Gaussian sources)\ncomponents  Array of sub-components for multi-component sources","category":"section"},{"location":"sources/#Example","page":"Source Models","title":"Example","text":"[\n  {\n    \"name\": \"Cyg A\",\n    \"components\": [\n      {\n        \"name\": \"1\",\n        \"ra\": \"19h59m29.990s\",\n        \"dec\": \"+40d43m57.53s\",\n        \"I\": 43170.55,\n        \"freq\": 1.0e6,\n        \"index\": [0.085, -0.178],\n        \"major-fwhm\": 127.87,\n        \"minor-fwhm\": 22.46,\n        \"position-angle\": -74.50\n      },\n      {\n        \"name\": \"2\",\n        \"ra\": \"19h59m24.316s\",\n        \"dec\": \"+40d44m50.70s\",\n        \"I\": 6374.46,\n        \"freq\": 1.0e6,\n        \"index\": [0.085, -0.178],\n        \"major-fwhm\": 183.43,\n        \"minor-fwhm\": 141.44,\n        \"position-angle\": 43.45\n      }\n    ]\n  },\n  {\n    \"name\": \"Cas A\",\n    \"ra\": \"23h23m27.94s\",\n    \"dec\": \"+58d48m42.4s\",\n    \"I\": 22000.0,\n    \"freq\": 1.0e6,\n    \"index\": [0.3, -0.2]\n  }\n]","category":"section"},{"location":"sources/#Spectral-Model","page":"Source Models","title":"Spectral Model","text":"Source flux follows a log-polynomial model:\n\nlog S(nu) = log S_0 + alpha_1 logleft(fracnunu_0right) + alpha_2 leftlogleft(fracnunu_0right)right^2 + cdots\n\nThis is implemented in GPUPowerLaw which stores:\n\nI, Q, U, V — Stokes parameters at the reference frequency\nreference_frequency — nu_0\nindex — coefficients alpha_1 alpha_2 ldots","category":"section"},{"location":"sources/#Source-Types","page":"Source Models","title":"Source Types","text":"","category":"section"},{"location":"sources/#Point-Source-(GPUPointSource)","page":"Source Models","title":"Point Source (GPUPointSource)","text":"Unresolved source. Model visibilities are pure fringes with flux scaling.","category":"section"},{"location":"sources/#Gaussian-Source-(GPUGaussianSource)","page":"Source Models","title":"Gaussian Source (GPUGaussianSource)","text":"Resolved source with an elliptical Gaussian shape. The baseline coherency is attenuated by the Fourier transform of the Gaussian envelope.","category":"section"},{"location":"sources/#Multi-component-Source-(GPUMultiSource)","page":"Source Models","title":"Multi-component Source (GPUMultiSource)","text":"A source composed of multiple sub-components (each a point or Gaussian source). Model visibilities are the sum of all component contributions.","category":"section"},{"location":"sources/#Peeling-Wrappers","page":"Source Models","title":"Peeling Wrappers","text":"Each source is wrapped in one of four peeling types that controls the calibration strategy:\n\nWrapper Jones type Frequency Function\nGPUPeelingSource Diagonal Per-channel peel_gpu!\nGPUShavingSource Diagonal Wideband shave_gpu!\nGPUZestingSource Full 2×2 Per-channel zest_gpu!\nGPUPruningSource Full 2×2 Wideband prune_gpu!","category":"section"},{"location":"tutorial/#tutorial","page":"Tutorial","title":"Tutorial","text":"A detailed walkthrough of using TTCalX for direction-dependent calibration, from quick verification to full production workflows.","category":"section"},{"location":"tutorial/#Table-of-Contents","page":"Tutorial","title":"Table of Contents","text":"Quick Test (Example Dataset)\nFull Workflow on Calim (Single MS)\nBatch Processing on Calim (Multiple MS)\nExample Results\n\n","category":"section"},{"location":"tutorial/#Quick-Test-(Example-Dataset)","page":"Tutorial","title":"Quick Test (Example Dataset)","text":"A small test dataset (6 channels, ~22 MB) is included in examples/ for quick verification. This MS was extracted from a calibrated OVRO-LWA observation at 73 MHz.\n\nSet up a working directory and run the quick test on calim:\n\nttcalx_env\n\n# Create a working directory and copy the example MS (never modify originals)\nmkdir -p /lustre/$USER/ttcalx_test && cd /lustre/$USER/ttcalx_test\ncp -r /opt/devel/nkosogor/nkosogor/TTCalX/examples/20240524_090003_73MHz_ch0to5.ms test_zest.ms\n\n# Run zest (use --column=DATA for split data)\nttcalx zest /home/pipeline/sources.json test_zest.ms \\\n    --column=DATA --verbose --maxiter=30 --tolerance=1e-4 --minuvw=10\n\nImage the peeled data with wsclean (dirty image):\n\nAfter peeling, TTCalX writes the calibrated visibilities back to the DATA column. Make a quick dirty image to verify using the orca Python wrapper:\n\nfrom pathlib import Path\nfrom orca.wrapper.wsclean import wsclean\n\nms = Path(\"test_zest.ms\").resolve()\nout_dir = Path(\"images\").resolve()\nout_dir.mkdir(parents=True, exist_ok=True)\n\nwsclean(\n    ms_list=[str(ms)],\n    out_dir=str(out_dir),\n    filename_prefix=\"peeled_73MHz_test\",\n    extra_arg_list=[\n        \"-pol\", \"IV\",\n        \"-size\", \"4096\", \"4096\",\n        \"-scale\", \"0.03125\",\n        \"-niter\", \"0\",\n        \"-weight\", \"briggs\", \"0\",\n        \"-horizon-mask\", \"10deg\",\n        \"-taper-inner-tukey\", \"30\",\n    ],\n    num_threads=4,\n    mem_gb=50,\n)\n\n","category":"section"},{"location":"tutorial/#Full-Workflow-on-Calim-(Single-MS)","page":"Tutorial","title":"Full Workflow on Calim (Single MS)","text":"A typical OVRO-LWA calibration workflow: copy data → apply bandpass/delay calibration → peel/zest bright sources → image.","category":"section"},{"location":"tutorial/#Step-1:-Copy-data-to-working-directory","page":"Tutorial","title":"Step 1: Copy data to working directory","text":"Always work on a copy — never modify pipeline originals.\n\nmkdir -p /lustre/$USER/ttcalx_test && cd /lustre/$USER/ttcalx_test\ncp -r /lustre/pipeline/night-time/averaged/73MHz/2024-05-24/09/20240524_090003_73MHz_averaged.ms .\nls -ld 20240524_090003_73MHz_averaged.ms","category":"section"},{"location":"tutorial/#Step-2:-Apply-bandpass-and-delay-calibration","page":"Tutorial","title":"Step 2: Apply bandpass and delay calibration","text":"ttcalx_env\ncd /lustre/$USER/ttcalx_test\n\npython3 -c \"\nfrom casatasks import applycal\n\nMS = '20240524_090003_73MHz_averaged.ms'\nDELAY_TABLE  = '/lustre/pipeline/calibration/delay/2024-05-24/20240524_delay.delay'\nBANDPASS_TBL = '/lustre/pipeline/calibration/bandpass/73MHz/2024-05-24/11/bandpass_concat.73MHz_11.bandpass'\n\napplycal(\n    vis=MS,\n    gaintable=[DELAY_TABLE, BANDPASS_TBL],\n    calwt=[False],\n    flagbackup=True,\n)\n\"","category":"section"},{"location":"tutorial/#Step-3:-Peel/zest-bright-sources-with-TTCalX","page":"Tutorial","title":"Step 3: Peel/zest bright sources with TTCalX","text":"ttcalx zest /home/pipeline/sources.json 20240524_090003_73MHz_averaged.ms \\\n    --verbose --maxiter=30 --tolerance=1e-4 --minuvw=10","category":"section"},{"location":"tutorial/#Step-4:-Image-with-wsclean","page":"Tutorial","title":"Step 4: Image with wsclean","text":"from pathlib import Path\nfrom orca.wrapper.wsclean import wsclean\n\nms = Path(\"20240524_090003_73MHz_averaged.ms\").resolve()\nout_dir = Path(\"images\").resolve()\nout_dir.mkdir(parents=True, exist_ok=True)\n\nwsclean(\n    ms_list=[str(ms)],\n    out_dir=str(out_dir),\n    filename_prefix=\"zested_73MHz\",\n    extra_arg_list=[\n        \"-pol\", \"IV\",\n        \"-size\", \"4096\", \"4096\",\n        \"-scale\", \"0.03125\",\n        \"-niter\", \"0\",\n        \"-weight\", \"briggs\", \"0\",\n        \"-horizon-mask\", \"10deg\",\n        \"-taper-inner-tukey\", \"30\",\n    ],\n    num_threads=4,\n    mem_gb=50,\n)\n\n","category":"section"},{"location":"tutorial/#Batch-Processing-on-Calim-(Multiple-MS)","page":"Tutorial","title":"Batch Processing on Calim (Multiple MS)","text":"Process multiple MS files end-to-end: copy → applycal → zest in batch.","category":"section"},{"location":"tutorial/#Step-1:-Copy-data-to-working-directory-2","page":"Tutorial","title":"Step 1: Copy data to working directory","text":"mkdir -p /lustre/$USER/ttcalx_batch && cd /lustre/$USER/ttcalx_batch\nSRC=/lustre/pipeline/night-time/averaged/73MHz/2024-05-24/09\ncp -r $SRC/20240524_090003_73MHz_averaged.ms .\ncp -r $SRC/20240524_093009_73MHz_averaged.ms .\ncp -r $SRC/20240524_095904_73MHz_averaged.ms .","category":"section"},{"location":"tutorial/#Step-2:-Apply-calibration-to-all-files","page":"Tutorial","title":"Step 2: Apply calibration to all files","text":"ttcalx_env\ncd /lustre/$USER/ttcalx_batch\n\npython3 -c \"\nfrom casatasks import applycal\n\nDELAY_TABLE  = '/lustre/pipeline/calibration/delay/2024-05-24/20240524_delay.delay'\nBANDPASS_TBL = '/lustre/pipeline/calibration/bandpass/73MHz/2024-05-24/11/bandpass_concat.73MHz_11.bandpass'\n\nms_files = [\n    '20240524_090003_73MHz_averaged.ms',\n    '20240524_093009_73MHz_averaged.ms',\n    '20240524_095904_73MHz_averaged.ms',\n]\n\nfor ms in ms_files:\n    print(f'Applying calibration to {ms}...')\n    applycal(\n        vis=ms,\n        gaintable=[DELAY_TABLE, BANDPASS_TBL],\n        calwt=[False],\n        flagbackup=True,\n    )\n    print(f'  Done: {ms}')\n\"","category":"section"},{"location":"tutorial/#Step-3:-Zest-all-files-in-batch-mode","page":"Tutorial","title":"Step 3: Zest all files in batch mode","text":"Pass all MS files at once so TTCalX only compiles once:\n\nttcalx zest /home/pipeline/sources.json \\\n    20240524_090003_73MHz_averaged.ms \\\n    20240524_093009_73MHz_averaged.ms \\\n    20240524_095904_73MHz_averaged.ms \\\n    --maxiter=30 --tolerance=1e-4 --minuvw=10\n\nOr using a glob:\n\nttcalx zest /home/pipeline/sources.json *.ms \\\n    --maxiter=30 --tolerance=1e-4 --minuvw=10","category":"section"},{"location":"tutorial/#Step-4:-Image-all-peeled-files","page":"Tutorial","title":"Step 4: Image all peeled files","text":"from pathlib import Path\nfrom orca.wrapper.wsclean import wsclean\n\nms_files = [\n    \"20240524_090003_73MHz_averaged.ms\",\n    \"20240524_093009_73MHz_averaged.ms\",\n    \"20240524_095904_73MHz_averaged.ms\",\n]\n\nout_dir = Path(\"images\").resolve()\nout_dir.mkdir(parents=True, exist_ok=True)\n\nfor ms_name in ms_files:\n    ms = Path(ms_name).resolve()\n    prefix = ms.stem.replace(\"_averaged\", \"_zested\")\n    print(f\"Imaging {ms_name} -> {prefix}\")\n    wsclean(\n        ms_list=[str(ms)],\n        out_dir=str(out_dir),\n        filename_prefix=prefix,\n        extra_arg_list=[\n            \"-pol\", \"IV\",\n            \"-size\", \"4096\", \"4096\",\n            \"-scale\", \"0.03125\",\n            \"-niter\", \"0\",\n            \"-weight\", \"briggs\", \"0\",\n            \"-horizon-mask\", \"10deg\",\n            \"-taper-inner-tukey\", \"30\",\n        ],\n        num_threads=4,\n        mem_gb=50,\n    )","category":"section"},{"location":"tutorial/#Expected-Performance","page":"Tutorial","title":"Expected Performance","text":"Benchmarked on calim server (NVIDIA RTX A4000 16 GB) with 73 MHz data (352 antennas, 48 channels, zest mode):\n\nMS file Time Notes\n1st file ~27s Includes JIT compilation\n2nd file ~5-10s Full GPU speed\n3rd file ~5-10s Full GPU speed\nAverage (excl. JIT) ~5-10s \n\ntip: Tip\nAlways use batch mode — pass all MS files in a single ttcalx call to pay the JIT cost only once.\n\n","category":"section"},{"location":"tutorial/#Example-Results","page":"Tutorial","title":"Example Results","text":"Below are dirty images (Stokes I, niter=0) showing the effect of peeling with TTCalX.","category":"section"},{"location":"tutorial/#Quick-Test-(6-channels)","page":"Tutorial","title":"Quick Test (6 channels)","text":"(Image: Quick Test: Before vs After Peeling)","category":"section"},{"location":"tutorial/#Full-MS-(48-channels)","page":"Tutorial","title":"Full MS (48 channels)","text":"09:00:03 UTC: (Image: 09:00:03 Before vs After)\n\n09:30:09 UTC: (Image: 09:30:09 Before vs After)\n\n09:59:04 UTC: (Image: 09:59:04 Before vs After)","category":"section"}]
}
